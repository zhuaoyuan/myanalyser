# Q1

使用 akshare 获取基金数据，并保存到本地。
步骤为；
1. 获取基金列表和申购信息，方法：
```
fund_purchase_em_df = ak.fund_purchase_em()
```
提取结果中的字段：基金代码、基金简称、申购状态、赎回状态、下一开放日、购买起点、日累计限定金额、手续费
将结果持久化到文件。

2. 根据1中得到的结果文件，依次根据基金代码使用下述方法获取基金详情：
```
fund_overview_em_df = ak.fund_overview_em(symbol="015641")
```
提取结果中的字段：基金代码、基金简称、基金全称、基金类型、发行日期、成立日期/规模、资产规模、份额规模、基金管理人、基金托管人、基金经理人、成立来分红、管理费率、托管费率、销售服务费率、最高认购费率、业绩比较基准、跟踪标的。将该结果持久化到文件。每次查询前预先检查，如果结果文件中存在该基金代码，则跳过。

3. 根据1中得到的结果文件，依次根据基金代码，获取基金历史累计净值，方法：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="166009", indicator="累计净值走势")
```
每行按基金代码、净值日期、累计净值的格式持久化到结果文件。


注意：
1. 对每个要使用的接口，都先测试调用一遍，确认结果的数据结构，以及在真实响应结果中，所有需求提及所需的字段是否都能找到对应的字段，如果有问题需确认和排查清楚。
2. 对于步骤2和3，接口是按基金代码单个获取的，且总基金数量很多。需要考虑如果失败如何重试，如果重试一直失败如何记录、是否支持后续手动重试，而不是从头开始。
3. 对于步骤3，数据量可能比较大。预计百万级别。需要考虑持久化结果的方式如何设计。
4. 需要设计测试用例，是每一步任务可以自动化闭环验证。


---

# A1

已实现一套独立于现有本地逻辑的 AkShare 基金采集脚本与自动化测试，满足你列的 1/2/3 步和注意事项。

新增文件

fund_etl.py
test_fund_etl.py
实现内容

步骤1：调用 ak.fund_purchase_em()，提取并落盘
字段：基金代码, 基金简称, 申购状态, 赎回状态, 下一开放日, 购买起点, 日累计限定金额, 手续费
步骤2：基于步骤1结果按代码调用 ak.fund_overview_em(symbol=...)
结果中做字段映射：AkShare 的 净资产规模 -> 需求字段 资产规模
先检查已存在结果文件里的基金代码，存在则跳过
失败自动重试（可配置），最终失败写入 jsonl 失败日志
支持仅对失败代码重跑（无需从头开始）
步骤3：基于步骤1结果按代码调用 ak.fund_open_fund_info_em(symbol=..., indicator="累计净值走势")
按 基金代码, 净值日期, 累计净值 持久化
为百万级数据采用“按基金代码分文件”存储：{code}.csv，天然支持断点续跑与跳过已完成代码
失败同样记录并支持后续失败重跑
接口预检：verify_interfaces() 会真实调用三类接口并输出字段校验报告（含缺失项、列名映射结论）
CLI 用法

全流程：
fund_etl.py --mode all
仅预检：
fund_etl.py --mode verify
单步：step1 | step2 | step3
重跑失败：retry-overview | retry-nav | retry-all
可调重试：--max-retries、--retry-sleep
输出目录可配：--base-dir（默认 myanalyser/data/fund_etl）
自动化测试

测试文件：test_fund_etl.py
覆盖点：
接口字段预检与“资产规模映射”校验
步骤1字段提取与落盘
步骤2已完成跳过、失败重试/记录
步骤3按代码文件落盘与行数校验
已执行：
python -m unittest -v test_fund_etl.py
结果：4 个测试全部通过
当前环境说明

我在当前沙箱里尝试了真实 --mode verify，因 DNS/外网限制无法访问 fund.eastmoney.com（不是代码错误）。
你在本机可联网环境运行上述命令即可生成真实校验报告和正式数据。

---



---

