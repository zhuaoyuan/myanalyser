# Q1

使用 akshare 获取基金数据，并保存到本地。
步骤为；
1. 获取基金列表和申购信息，方法：
```
fund_purchase_em_df = ak.fund_purchase_em()
```
提取结果中的字段：基金代码、基金简称、申购状态、赎回状态、下一开放日、购买起点、日累计限定金额、手续费
将结果持久化到文件。

2. 根据1中得到的结果文件，依次根据基金代码使用下述方法获取基金详情：
```
fund_overview_em_df = ak.fund_overview_em(symbol="015641")
```
提取结果中的字段：基金代码、基金简称、基金全称、基金类型、发行日期、成立日期/规模、资产规模、份额规模、基金管理人、基金托管人、基金经理人、成立来分红、管理费率、托管费率、销售服务费率、最高认购费率、业绩比较基准、跟踪标的。将该结果持久化到文件。每次查询前预先检查，如果结果文件中存在该基金代码，则跳过。

3. 根据1中得到的结果文件，依次根据基金代码，获取基金历史累计净值，方法：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="166009", indicator="累计净值走势")
```
每行按基金代码、净值日期、累计净值的格式持久化到结果文件。


注意：
1. 对每个要使用的接口，都先测试调用一遍，确认结果的数据结构，以及在真实响应结果中，所有需求提及所需的字段是否都能找到对应的字段，如果有问题需确认和排查清楚。
2. 对于步骤2和3，接口是按基金代码单个获取的，且总基金数量很多。需要考虑如果失败如何重试，如果重试一直失败如何记录、是否支持后续手动重试，而不是从头开始。
3. 对于步骤3，数据量可能比较大。预计百万级别。需要考虑持久化结果的方式如何设计。
4. 需要设计测试用例，每一步任务可以自动化闭环验证。


---

# A1

已实现一套独立于现有本地逻辑的 AkShare 基金采集脚本与自动化测试，满足你列的 1/2/3 步和注意事项。

新增文件

fund_etl.py
test_fund_etl.py
实现内容

步骤1：调用 ak.fund_purchase_em()，提取并落盘
字段：基金代码, 基金简称, 申购状态, 赎回状态, 下一开放日, 购买起点, 日累计限定金额, 手续费
步骤2：基于步骤1结果按代码调用 ak.fund_overview_em(symbol=...)
结果中做字段映射：AkShare 的 净资产规模 -> 需求字段 资产规模
先检查已存在结果文件里的基金代码，存在则跳过
失败自动重试（可配置），最终失败写入 jsonl 失败日志
支持仅对失败代码重跑（无需从头开始）
步骤3：基于步骤1结果按代码调用 ak.fund_open_fund_info_em(symbol=..., indicator="累计净值走势")
按 基金代码, 净值日期, 累计净值 持久化
为百万级数据采用“按基金代码分文件”存储：{code}.csv，天然支持断点续跑与跳过已完成代码
失败同样记录并支持后续失败重跑
接口预检：verify_interfaces() 会真实调用三类接口并输出字段校验报告（含缺失项、列名映射结论）
CLI 用法

全流程：
fund_etl.py --mode all
仅预检：
fund_etl.py --mode verify
单步：step1 | step2 | step3
重跑失败：retry-overview | retry-nav | retry-all
可调重试：--max-retries、--retry-sleep
输出目录可配：--base-dir（默认 myanalyser/data/fund_etl）
自动化测试

测试文件：test_fund_etl.py
覆盖点：
接口字段预检与“资产规模映射”校验
步骤1字段提取与落盘
步骤2已完成跳过、失败重试/记录
步骤3按代码文件落盘与行数校验
已执行：
python -m unittest -v test_fund_etl.py
结果：4 个测试全部通过
当前环境说明

我在当前沙箱里尝试了真实 --mode verify，因 DNS/外网限制无法访问 fund.eastmoney.com（不是代码错误）。
你在本机可联网环境运行上述命令即可生成真实校验报告和正式数据。

---

# Q2

步骤2、步骤3执行过程中以合适的间隔打印进度。
步骤2、步骤3使用多线程的方式，且使用持续增量持久化的方式，不要全部跑完后才持久化。
需要设计测试用例，每一步任务可以自动化闭环验证。
@fund_etl.py

---

# A2

已按你的要求完成改造，核心点如下。

步骤2/步骤3改为多线程执行
fund_etl.py (line 229)、fund_etl.py (line 338)
使用 ThreadPoolExecutor + as_completed 并发按基金代码抓取。
新增 max_workers 参数（CLI: --max-workers）。
步骤2/步骤3增加“合适间隔”的进度打印
fund_etl.py (line 56)、fund_etl.py (line 215)、fund_etl.py (line 289)、fund_etl.py (line 393)
新增 ProgressConfig(print_interval_seconds)。
执行中按时间间隔打印进度，结束时强制打印一次总结。
CLI 新增 --progress-interval。
持续增量持久化（不是全部跑完再写）
fund_etl.py (line 276)、fund_etl.py (line 385)
步骤2：每个 future 完成后立即 append 到 overview_csv。
步骤3：每个 future 完成后立即写对应 {code}.csv。
自动化闭环测试用例补齐
test_fund_etl.py (line 141)、test_fund_etl.py (line 217)、test_fund_etl.py (line 250)
新增步骤2并发+增量持久化+进度打印测试。
新增步骤3并发+进度打印+部分失败测试。
新增 step1→step2→step3 全流程闭环测试。
验证结果（本地执行）

命令：activate && cd myanalyser && python -m unittest -v test_fund_etl.py
结果：Ran 7 tests ... OK（全部通过）

---

# Q3 

1. 将 step3改为获取单位净值而不是累计净值，代码和结果示例：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="163402", indicator="单位净值走势")
print(fund_open_fund_info_em_df)
#             净值日期    单位净值  日增长率
# 0     2005-11-03  1.0000  0.00
# 1     2005-11-11  0.9999 -0.01
# 2     2005-11-16  0.9999  0.00
# 3     2005-11-17  0.9999  0.00
# 4     2005-11-18  1.0007  0.08
# ...          ...     ...   ...
# 4932  2026-02-09  0.8015  2.35
# 4933  2026-02-10  0.8060  0.56
# 4934  2026-02-11  0.8029 -0.38
# 4935  2026-02-12  0.8105  0.95
# 4936  2026-02-13  0.8002 -1.27
```

2. 增加step4，获取分红送配详情，代码和结果示例（如果无任何结果则对应结果文件为空，便于断点重试）：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="163402", indicator="分红送配详情")
print(fund_open_fund_info_em_df)
#        年份       权益登记日         除息日          每份分红       分红发放日
# 0   2021年  2021-12-16  2021-12-16  每份派现金0.1584元  2021-12-20
# 1   2020年  2020-08-10  2020-08-10  每份派现金0.0820元  2020-08-12
# 2   2019年  2019-09-24  2019-09-24  每份派现金0.1000元  2019-09-26
# 3   2018年  2018-09-19  2018-09-19  每份派现金0.1821元  2018-09-21
# 4   2017年  2017-08-28  2017-08-28  每份派现金0.2647元  2017-08-30
# 5   2016年  2016-12-12  2016-12-12  每份派现金0.6108元  2016-12-14
# 6   2015年  2015-01-13  2015-01-13  每份派现金0.1030元  2015-01-15
# 7   2014年  2014-07-17  2014-07-17  每份派现金0.0300元  2014-07-21
# 8   2011年  2011-12-20  2011-12-20  每份派现金0.0580元  2011-12-22
# 9   2010年  2010-10-20  2010-10-20  每份派现金0.0800元  2010-10-22
# 10  2009年  2009-08-17  2009-08-17  每份派现金0.1000元  2009-08-19
# 11  2008年  2008-12-19  2008-12-19  每份派现金0.0420元  2008-12-23
# 12  2007年  2007-06-25  2007-06-25  每份派现金0.1300元  2007-06-27
# 13  2006年  2006-03-13  2006-03-13  每份派现金0.0760元  2006-03-15
# 14  2006年  2006-01-24  2006-01-24  每份派现金0.0240元  2006-02-06
```

3. 增加step5，获取拆分详情，代码和结果示例（如果无任何结果则对应结果文件为空，便于断点重试）：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="163402", indicator="拆分详情")
print(fund_open_fund_info_em_df)
#       年份       拆分折算日  拆分类型    拆分折算比例
# 0  2007年  2007-05-11  份额折算  1:3.9939
```

注意：
1. step3、step4和step5都无需多线程请求，都要按合理间隔打印进度，每查完一次就持久化一个文件。

---

# A3

已按你的要求完成改造并验证通过。

变更如下：

1. `step3` 改为抓取“单位净值走势”，并改为串行请求  
- 抓取指标：`indicator="单位净值走势"`  
- 输出列：`基金代码, 净值日期, 单位净值, 日增长率`  
- 不再多线程执行；如果传入 `max_workers>1` 会提示忽略  
- 每个基金代码查询成功后立即落盘一个文件（`{code}.csv`）  
- 代码位置：`myanalyser/fund_etl.py:327`

2. 新增 `step4`：分红送配详情  
- 抓取指标：`indicator="分红送配详情"`  
- 输出目录：`fund_bonus_by_code`  
- 输出列：`基金代码, 年份, 权益登记日, 除息日, 每份分红, 分红发放日`  
- 串行请求，按进度间隔打印，单代码单文件持久化  
- 无数据时也会写出空文件（仅表头），便于断点重试  
- 代码位置：`myanalyser/fund_etl.py:540`

3. 新增 `step5`：拆分详情  
- 抓取指标：`indicator="拆分详情"`  
- 输出目录：`fund_split_by_code`  
- 输出列：`基金代码, 年份, 拆分折算日, 拆分类型, 拆分折算比例`  
- 串行请求，按进度间隔打印，单代码单文件持久化  
- 无数据时也会写出空文件（仅表头），便于断点重试  
- 代码位置：`myanalyser/fund_etl.py:564`

4. CLI 与路径已扩展  
- 新增模式：`step4`, `step5`, `retry-bonus`, `retry-split`  
- `all` 会执行到 step5；`retry-all` 会包含 bonus/split 重试  
- 新增失败日志：`failed_bonus.jsonl`, `failed_split.jsonl`  
- 代码位置：`myanalyser/fund_etl.py:592`, `myanalyser/fund_etl.py:606`

5. 接口校验 `verify_interfaces` 已同步  
- `step3` 校验改为单位净值字段  
- 新增 bonus/split 字段校验  
- 代码位置：`myanalyser/fund_etl.py:95`

6. 测试已同步并通过  
- 更新并新增了 step3/step4/step5 的单测（含空结果落盘场景）  
- 文件：`myanalyser/test_fund_etl.py`  
- 执行：`source myanalyser/.venv312/bin/activate && cd myanalyser && python -m unittest -q test_fund_etl.py`  
- 结果：`Ran 9 tests ... OK`

---

# Q4
增加step6，获取基金人事公告，代码和结果示例（如果无任何结果则对应结果文件为空，便于断点重试）：
```
fund_announcement_personnel_em_df = ak.fund_announcement_personnel_em(symbol="000001")
print(fund_announcement_personnel_em_df)
#       基金代码                               公告标题    基金名称        公告日期                  报告ID
# 0   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2013-06-29  AN201306290003484248
# 1   000001    华夏基金管理有限公司关于增聘华夏成长证券投资基金基金经理的公告  华夏成长混合  2014-03-18  AN201403180005270024
# 2   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2014-06-21  AN201406210006119867
# 3   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2015-01-09  AN201501090008098479
# 4   000001  华夏基金管理有限公司关于调整华夏成长证券投资公告基金基金经理的公告  华夏成长混合  2015-11-21  AN201511210011484696
# 5   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2017-01-14  AN201701140268312342
# 6   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2017-02-25  AN201702250364410226
# 7   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2017-03-30  AN201703300451418174
# 8   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2021-02-24  AN202102241464811736
# 9   000001    华夏基金管理有限公司关于增聘华夏成长证券投资基金基金经理的公告  华夏成长混合  2021-09-18  AN202109181516930266
# 10  000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2022-04-13  AN202204131558964253
# 11  000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2022-10-29  AN202210291579611414
```

---

# A4

已在 `myanalyser/fund_etl.py` 完成 `step6`（基金人事公告）接入，并补齐测试。

主要改动：
- 新增字段常量与标准化：
  - `myanalyser/fund_etl.py:50` `PERSONNEL_COLUMNS`
  - `myanalyser/fund_etl.py:598` `_normalize_personnel(...)`
- 新增采集步骤：
  - `myanalyser/fund_etl.py:608` `run_step6_personnel(...)`
  - 使用 `ak.fund_announcement_personnel_em(symbol=code)`
  - 串行逐基金抓取、按间隔打印进度、每个基金即时写文件
  - 无结果也会写出空 CSV（仅表头），用于断点续跑
- 接入 `verify` 检查：
  - `myanalyser/fund_etl.py:111` 增加 `fund_announcement_personnel_em` 调用
  - `myanalyser/fund_etl.py:172` 增加所需字段校验结果
- 接入 CLI 与重试：
  - `myanalyser/fund_etl.py:731` 新增 `step6`
  - `myanalyser/fund_etl.py:737` 新增 `retry-personnel`
  - `myanalyser/fund_etl.py:709` 新增输出目录 `fund_personnel_by_code`
  - `myanalyser/fund_etl.py:715` 新增失败日志 `failed_personnel.jsonl`
  - `myanalyser/fund_etl.py:806` `all` 流程执行 `step6`
  - `myanalyser/fund_etl.py:866` `retry-all` 包含 `retry-personnel`

测试已补齐并通过：
- `myanalyser/test_fund_etl.py:317` 新增 `test_step6_personnel_write_empty_file_when_no_data`
- `myanalyser/test_fund_etl.py:432` 闭环测试扩展到 step6
- 执行命令：
  - `source myanalyser/.venv312/bin/activate && cd myanalyser && python -m unittest -q test_fund_etl.py`
- 结果：
  - `Ran 10 tests ... OK`

---

# Q5
针对failed_nav.jsonl编写一个单独的工具脚本，支持将指定失败日志文件转成 csv 格式。

---

# A5

已完成，新增了一个独立工具脚本：

- `myanalyser/failed_log_to_csv.py`
- `myanalyser/test_failed_log_to_csv.py`

功能：
- 支持 `--input/-i` 指定失败日志 `jsonl` 文件
- 支持 `--output/-o` 指定输出 `csv` 文件（不传则默认同名 `.csv`）
- 自动按 `ts, stage, code, error` 优先输出列，其余字段自动追加
- 兼容多行错误文本（CSV 会自动正确转义）

你可以这样用：

```bash
python3 myanalyser/failed_log_to_csv.py \
  -i myanalyser/myanalyser/data/fund_etl/failed_nav.jsonl \
  -o myanalyser/myanalyser/data/fund_etl/failed_nav.csv
```

我已实跑成功，生成：
- `myanalyser/myanalyser/data/fund_etl/failed_nav.csv`（1191 行）

并且测试通过：
- 在 `myanalyser` 目录执行 `python3 -m unittest test_failed_log_to_csv.py` 通过。

---

TODO 
fund_etl.py 失败日志改为csv格式

计算复权净值