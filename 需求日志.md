# Q1

使用 akshare 获取基金数据，并保存到本地。
步骤为；
1. 获取基金列表和申购信息，方法：
```
fund_purchase_em_df = ak.fund_purchase_em()
```
提取结果中的字段：基金代码、基金简称、申购状态、赎回状态、下一开放日、购买起点、日累计限定金额、手续费
将结果持久化到文件。

2. 根据1中得到的结果文件，依次根据基金代码使用下述方法获取基金详情：
```
fund_overview_em_df = ak.fund_overview_em(symbol="015641")
```
提取结果中的字段：基金代码、基金简称、基金全称、基金类型、发行日期、成立日期/规模、资产规模、份额规模、基金管理人、基金托管人、基金经理人、成立来分红、管理费率、托管费率、销售服务费率、最高认购费率、业绩比较基准、跟踪标的。将该结果持久化到文件。每次查询前预先检查，如果结果文件中存在该基金代码，则跳过。

3. 根据1中得到的结果文件，依次根据基金代码，获取基金历史累计净值，方法：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="166009", indicator="累计净值走势")
```
每行按基金代码、净值日期、累计净值的格式持久化到结果文件。


注意：
1. 对每个要使用的接口，都先测试调用一遍，确认结果的数据结构，以及在真实响应结果中，所有需求提及所需的字段是否都能找到对应的字段，如果有问题需确认和排查清楚。
2. 对于步骤2和3，接口是按基金代码单个获取的，且总基金数量很多。需要考虑如果失败如何重试，如果重试一直失败如何记录、是否支持后续手动重试，而不是从头开始。
3. 对于步骤3，数据量可能比较大。预计百万级别。需要考虑持久化结果的方式如何设计。
4. 需要设计测试用例，每一步任务可以自动化闭环验证。


---

# A1

已实现一套独立于现有本地逻辑的 AkShare 基金采集脚本与自动化测试，满足你列的 1/2/3 步和注意事项。

新增文件

fund_etl.py
test_fund_etl.py
实现内容

步骤1：调用 ak.fund_purchase_em()，提取并落盘
字段：基金代码, 基金简称, 申购状态, 赎回状态, 下一开放日, 购买起点, 日累计限定金额, 手续费
步骤2：基于步骤1结果按代码调用 ak.fund_overview_em(symbol=...)
结果中做字段映射：AkShare 的 净资产规模 -> 需求字段 资产规模
先检查已存在结果文件里的基金代码，存在则跳过
失败自动重试（可配置），最终失败写入 jsonl 失败日志
支持仅对失败代码重跑（无需从头开始）
步骤3：基于步骤1结果按代码调用 ak.fund_open_fund_info_em(symbol=..., indicator="累计净值走势")
按 基金代码, 净值日期, 累计净值 持久化
为百万级数据采用“按基金代码分文件”存储：{code}.csv，天然支持断点续跑与跳过已完成代码
失败同样记录并支持后续失败重跑
接口预检：verify_interfaces() 会真实调用三类接口并输出字段校验报告（含缺失项、列名映射结论）
CLI 用法

全流程：
fund_etl.py --mode all
仅预检：
fund_etl.py --mode verify
单步：step1 | step2 | step3
重跑失败：retry-overview | retry-nav | retry-all
可调重试：--max-retries、--retry-sleep
输出目录可配：--base-dir（默认 myanalyser/data/fund_etl）
自动化测试

测试文件：test_fund_etl.py
覆盖点：
接口字段预检与“资产规模映射”校验
步骤1字段提取与落盘
步骤2已完成跳过、失败重试/记录
步骤3按代码文件落盘与行数校验
已执行：
python -m unittest -v test_fund_etl.py
结果：4 个测试全部通过
当前环境说明

我在当前沙箱里尝试了真实 --mode verify，因 DNS/外网限制无法访问 fund.eastmoney.com（不是代码错误）。
你在本机可联网环境运行上述命令即可生成真实校验报告和正式数据。

---

# Q2

步骤2、步骤3执行过程中以合适的间隔打印进度。
步骤2、步骤3使用多线程的方式，且使用持续增量持久化的方式，不要全部跑完后才持久化。
需要设计测试用例，每一步任务可以自动化闭环验证。
@fund_etl.py

---

# A2

已按你的要求完成改造，核心点如下。

步骤2/步骤3改为多线程执行
fund_etl.py (line 229)、fund_etl.py (line 338)
使用 ThreadPoolExecutor + as_completed 并发按基金代码抓取。
新增 max_workers 参数（CLI: --max-workers）。
步骤2/步骤3增加“合适间隔”的进度打印
fund_etl.py (line 56)、fund_etl.py (line 215)、fund_etl.py (line 289)、fund_etl.py (line 393)
新增 ProgressConfig(print_interval_seconds)。
执行中按时间间隔打印进度，结束时强制打印一次总结。
CLI 新增 --progress-interval。
持续增量持久化（不是全部跑完再写）
fund_etl.py (line 276)、fund_etl.py (line 385)
步骤2：每个 future 完成后立即 append 到 overview_csv。
步骤3：每个 future 完成后立即写对应 {code}.csv。
自动化闭环测试用例补齐
test_fund_etl.py (line 141)、test_fund_etl.py (line 217)、test_fund_etl.py (line 250)
新增步骤2并发+增量持久化+进度打印测试。
新增步骤3并发+进度打印+部分失败测试。
新增 step1→step2→step3 全流程闭环测试。
验证结果（本地执行）

命令：activate && cd myanalyser && python -m unittest -v test_fund_etl.py
结果：Ran 7 tests ... OK（全部通过）

---

# Q3 

1. 将 step3改为获取单位净值而不是累计净值，代码和结果示例：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="163402", indicator="单位净值走势")
print(fund_open_fund_info_em_df)
#             净值日期    单位净值  日增长率
# 0     2005-11-03  1.0000  0.00
# 1     2005-11-11  0.9999 -0.01
# 2     2005-11-16  0.9999  0.00
# 3     2005-11-17  0.9999  0.00
# 4     2005-11-18  1.0007  0.08
# ...          ...     ...   ...
# 4932  2026-02-09  0.8015  2.35
# 4933  2026-02-10  0.8060  0.56
# 4934  2026-02-11  0.8029 -0.38
# 4935  2026-02-12  0.8105  0.95
# 4936  2026-02-13  0.8002 -1.27
```

2. 增加step4，获取分红送配详情，代码和结果示例（如果无任何结果则对应结果文件为空，便于断点重试）：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="163402", indicator="分红送配详情")
print(fund_open_fund_info_em_df)
#        年份       权益登记日         除息日          每份分红       分红发放日
# 0   2021年  2021-12-16  2021-12-16  每份派现金0.1584元  2021-12-20
# 1   2020年  2020-08-10  2020-08-10  每份派现金0.0820元  2020-08-12
# 2   2019年  2019-09-24  2019-09-24  每份派现金0.1000元  2019-09-26
# 3   2018年  2018-09-19  2018-09-19  每份派现金0.1821元  2018-09-21
# 4   2017年  2017-08-28  2017-08-28  每份派现金0.2647元  2017-08-30
# 5   2016年  2016-12-12  2016-12-12  每份派现金0.6108元  2016-12-14
# 6   2015年  2015-01-13  2015-01-13  每份派现金0.1030元  2015-01-15
# 7   2014年  2014-07-17  2014-07-17  每份派现金0.0300元  2014-07-21
# 8   2011年  2011-12-20  2011-12-20  每份派现金0.0580元  2011-12-22
# 9   2010年  2010-10-20  2010-10-20  每份派现金0.0800元  2010-10-22
# 10  2009年  2009-08-17  2009-08-17  每份派现金0.1000元  2009-08-19
# 11  2008年  2008-12-19  2008-12-19  每份派现金0.0420元  2008-12-23
# 12  2007年  2007-06-25  2007-06-25  每份派现金0.1300元  2007-06-27
# 13  2006年  2006-03-13  2006-03-13  每份派现金0.0760元  2006-03-15
# 14  2006年  2006-01-24  2006-01-24  每份派现金0.0240元  2006-02-06
```

3. 增加step5，获取拆分详情，代码和结果示例（如果无任何结果则对应结果文件为空，便于断点重试）：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="163402", indicator="拆分详情")
print(fund_open_fund_info_em_df)
#       年份       拆分折算日  拆分类型    拆分折算比例
# 0  2007年  2007-05-11  份额折算  1:3.9939
```

注意：
1. step3、step4和step5都无需多线程请求，都要按合理间隔打印进度，每查完一次就持久化一个文件。

---

# A3

已按你的要求完成改造并验证通过。

变更如下：

1. `step3` 改为抓取“单位净值走势”，并改为串行请求  
- 抓取指标：`indicator="单位净值走势"`  
- 输出列：`基金代码, 净值日期, 单位净值, 日增长率`  
- 不再多线程执行；如果传入 `max_workers>1` 会提示忽略  
- 每个基金代码查询成功后立即落盘一个文件（`{code}.csv`）  
- 代码位置：`myanalyser/fund_etl.py:327`

2. 新增 `step4`：分红送配详情  
- 抓取指标：`indicator="分红送配详情"`  
- 输出目录：`fund_bonus_by_code`  
- 输出列：`基金代码, 年份, 权益登记日, 除息日, 每份分红, 分红发放日`  
- 串行请求，按进度间隔打印，单代码单文件持久化  
- 无数据时也会写出空文件（仅表头），便于断点重试  
- 代码位置：`myanalyser/fund_etl.py:540`

3. 新增 `step5`：拆分详情  
- 抓取指标：`indicator="拆分详情"`  
- 输出目录：`fund_split_by_code`  
- 输出列：`基金代码, 年份, 拆分折算日, 拆分类型, 拆分折算比例`  
- 串行请求，按进度间隔打印，单代码单文件持久化  
- 无数据时也会写出空文件（仅表头），便于断点重试  
- 代码位置：`myanalyser/fund_etl.py:564`

4. CLI 与路径已扩展  
- 新增模式：`step4`, `step5`, `retry-bonus`, `retry-split`  
- `all` 会执行到 step5；`retry-all` 会包含 bonus/split 重试  
- 新增失败日志：`failed_bonus.jsonl`, `failed_split.jsonl`  
- 代码位置：`myanalyser/fund_etl.py:592`, `myanalyser/fund_etl.py:606`

5. 接口校验 `verify_interfaces` 已同步  
- `step3` 校验改为单位净值字段  
- 新增 bonus/split 字段校验  
- 代码位置：`myanalyser/fund_etl.py:95`

6. 测试已同步并通过  
- 更新并新增了 step3/step4/step5 的单测（含空结果落盘场景）  
- 文件：`myanalyser/test_fund_etl.py`  
- 执行：`source myanalyser/.venv312/bin/activate && cd myanalyser && python -m unittest -q test_fund_etl.py`  
- 结果：`Ran 9 tests ... OK`

---

# Q4
增加step6，获取基金人事公告，代码和结果示例（如果无任何结果则对应结果文件为空，便于断点重试）：
```
fund_announcement_personnel_em_df = ak.fund_announcement_personnel_em(symbol="000001")
print(fund_announcement_personnel_em_df)
#       基金代码                               公告标题    基金名称        公告日期                  报告ID
# 0   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2013-06-29  AN201306290003484248
# 1   000001    华夏基金管理有限公司关于增聘华夏成长证券投资基金基金经理的公告  华夏成长混合  2014-03-18  AN201403180005270024
# 2   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2014-06-21  AN201406210006119867
# 3   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2015-01-09  AN201501090008098479
# 4   000001  华夏基金管理有限公司关于调整华夏成长证券投资公告基金基金经理的公告  华夏成长混合  2015-11-21  AN201511210011484696
# 5   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2017-01-14  AN201701140268312342
# 6   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2017-02-25  AN201702250364410226
# 7   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2017-03-30  AN201703300451418174
# 8   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2021-02-24  AN202102241464811736
# 9   000001    华夏基金管理有限公司关于增聘华夏成长证券投资基金基金经理的公告  华夏成长混合  2021-09-18  AN202109181516930266
# 10  000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2022-04-13  AN202204131558964253
# 11  000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2022-10-29  AN202210291579611414
```

---

# A4

已在 `myanalyser/fund_etl.py` 完成 `step6`（基金人事公告）接入，并补齐测试。

主要改动：
- 新增字段常量与标准化：
  - `myanalyser/fund_etl.py:50` `PERSONNEL_COLUMNS`
  - `myanalyser/fund_etl.py:598` `_normalize_personnel(...)`
- 新增采集步骤：
  - `myanalyser/fund_etl.py:608` `run_step6_personnel(...)`
  - 使用 `ak.fund_announcement_personnel_em(symbol=code)`
  - 串行逐基金抓取、按间隔打印进度、每个基金即时写文件
  - 无结果也会写出空 CSV（仅表头），用于断点续跑
- 接入 `verify` 检查：
  - `myanalyser/fund_etl.py:111` 增加 `fund_announcement_personnel_em` 调用
  - `myanalyser/fund_etl.py:172` 增加所需字段校验结果
- 接入 CLI 与重试：
  - `myanalyser/fund_etl.py:731` 新增 `step6`
  - `myanalyser/fund_etl.py:737` 新增 `retry-personnel`
  - `myanalyser/fund_etl.py:709` 新增输出目录 `fund_personnel_by_code`
  - `myanalyser/fund_etl.py:715` 新增失败日志 `failed_personnel.jsonl`
  - `myanalyser/fund_etl.py:806` `all` 流程执行 `step6`
  - `myanalyser/fund_etl.py:866` `retry-all` 包含 `retry-personnel`

测试已补齐并通过：
- `myanalyser/test_fund_etl.py:317` 新增 `test_step6_personnel_write_empty_file_when_no_data`
- `myanalyser/test_fund_etl.py:432` 闭环测试扩展到 step6
- 执行命令：
  - `source myanalyser/.venv312/bin/activate && cd myanalyser && python -m unittest -q test_fund_etl.py`
- 结果：
  - `Ran 10 tests ... OK`

---

# Q5
针对failed_nav.jsonl编写一个单独的工具脚本，支持将指定失败日志文件转成 csv 格式。

---

# A5

已完成，新增了一个独立工具脚本：

- `myanalyser/failed_log_to_csv.py`
- `myanalyser/test_failed_log_to_csv.py`

功能：
- 支持 `--input/-i` 指定失败日志 `jsonl` 文件
- 支持 `--output/-o` 指定输出 `csv` 文件（不传则默认同名 `.csv`）
- 自动按 `ts, stage, code, error` 优先输出列，其余字段自动追加
- 兼容多行错误文本（CSV 会自动正确转义）

你可以这样用：

```bash
python3 myanalyser/failed_log_to_csv.py \
  -i myanalyser/myanalyser/data/fund_etl/failed_nav.jsonl \
  -o myanalyser/myanalyser/data/fund_etl/failed_nav.csv
```

我已实跑成功，生成：
- `myanalyser/myanalyser/data/fund_etl/failed_nav.csv`（1191 行）

并且测试通过：
- 在 `myanalyser` 目录执行 `python3 -m unittest test_failed_log_to_csv.py` 通过。

---

# Q6

编写一个单独的工具脚本
基于单位净值、分红数据、拆分数据，计算各个基金的历史复权净值数据，以基金163402（/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/myanalyser/data/samples, 既有分红又有拆分）为例试运行并验证。计算方法参考：

```
import pandas as pd
import re

def calculate_adjusted_nav(df_nav, df_dividend, df_split):
    """
    df_nav: 单位净值走势 (包含: 净值日期, 单位净值)
    df_dividend: 分红送配详情 (包含: 除息日, 每份分红)
    df_split: 拆分详情 (包含: 拆分折算日, 拆分折算比例)
    """
    
    # 1. 预处理数据格式
    df_nav['净值日期'] = pd.to_datetime(df_nav['净值日期'])
    df_nav = df_nav.sort_values('净值日期').reset_index(drop=True)
    
    # 2. 提取分红金额数字 (例如 "每份派现金0.1584元" -> 0.1584)
    df_dividend['除息日'] = pd.to_datetime(df_dividend['除息日'])
    df_dividend['分红金额'] = df_dividend['每份分红'].str.extract(r'(\d+\.\d+)').astype(float)
    
    # 3. 提取拆分比例 (例如 "1:3.9939" -> 3.9939)
    df_split['拆分折算日'] = pd.to_datetime(df_split['拆分折算日'])
    df_split['拆分比例'] = df_split['拆分折算比例'].str.split(':').str[-1].astype(float)

    # 4. 初始化复权因子列
    # adj_factor 代表：如果你在这一天之前持有，为了保持逻辑连续，历史价格需要缩放的比例
    df_nav['adj_factor'] = 1.0

    # 5. 处理分红（分红再投资逻辑）
    for _, row in df_dividend.iterrows():
        div_date = row['除息日']
        div_amt = row['分红金额']
        # 找到除息日当天的净值
        today_nav = df_nav.loc[df_nav['净值日期'] == div_date, '单位净值']
        if not today_nav.empty:
            nav_val = today_nav.values[0]
            # 复权因子 = (除息后净值 + 分红) / 除息后净值
            # 这意味着分红的钱按当天价格买回了基金，增加了份额
            factor = (nav_val + div_amt) / nav_val
            df_nav.loc[df_nav['净值日期'] == div_date, 'adj_factor'] = factor

    # 6. 处理拆分
    for _, row in df_split.iterrows():
        split_date = row['拆分折算日']
        split_ratio = row['拆分比例']
        # 拆分后净值变小，份额变多。复权因子即比例本身
        df_nav.loc[df_nav['净值日期'] == split_date, 'adj_factor'] = split_ratio

    # 7. 计算累计复权因子并求得复权净值
    # 使用 cumprod (累乘) 从前往后计算
    df_nav['cumulative_factor'] = df_nav['adj_factor'].cumprod()
    df_nav['复权净值'] = df_nav['单位净值'] * df_nav['cumulative_factor']

    return df_nav[['净值日期', '单位净值', '复权净值', 'cumulative_factor']]

# 使用示例 (假设你已经定义了那三个 df)
# res_df = calculate_adjusted_nav(df_nav, df_dividend, df_split)
# print(res_df.tail())
```

---

# A6

已完成，新增了一个独立工具脚本并用 `163402` 样例实跑验证。

**新增文件**
- `myanalyser/adjusted_nav_tool.py`
- `myanalyser/test_adjusted_nav_tool.py`

**实现内容**
- 读取三类输入：单位净值、分红、拆分（按基金代码对应 CSV）。
- 按你给的方法计算：
  - 分红因子：`(当日单位净值 + 分红金额) / 当日单位净值`
  - 拆分因子：拆分比例（如 `1:3.9939 -> 3.9939`）
  - 累乘得到 `cumulative_factor`
  - `复权净值 = 单位净值 * cumulative_factor`
- 支持批量和指定代码处理，CLI 参数：
  - `--nav-dir`
  - `--bonus-dir`
  - `--split-dir`
  - `--output-dir`
  - `--codes`（可选）

**测试与验证**
- 测试执行：`python -m unittest myanalyser/test_adjusted_nav_tool.py`
- 结果：2 个测试全部通过。
- 样例实跑命令已执行，输出：
  - `processed funds: 1`
  - `163402: rows=4937 range=2005-11-03~2026-02-13`
- 输出文件：
  - `myanalyser/myanalyser/data/samples/fund_adjusted_nav_by_code/163402.csv`
- 关键校验（163402）：
  - `2006-01-24 cumulative_factor = 1.022468`
  - `2006-03-13 cumulative_factor = 1.098786`
  - `2007-05-11 cumulative_factor = 4.3884424059`
  - 事件公式复算值与输出完全一致（差值 `0.0`）。

---

# Q7
再略微调整一下。当前缺失分红日、拆分日异常记录保持不变。但脚本额外支持一个参数，指定一个日期，如果发生缺失的分红日、拆分日异常的日期晚于该指定日期，则该基金整体认为是异常，不记录。除此之外还是记录复权计算结果。

---
# A7

已按你的新规则改完，行为如下：

- 默认行为不变：  
  - 缺失分红日/拆分日仍判异常，记录 `failed_adjusted_nav.jsonl`，不产出该基金结果。
- 新增参数：`--allow-missing-event-until YYYY-MM-DD`  
  - 若缺失事件日 `<=` 该日期：允许跳过这些缺失事件，继续计算并写出复权结果。  
  - 若缺失事件日 `>` 该日期：仍判异常，不记录该基金结果（并写失败日志）。

关键改动：

- `myanalyser/adjusted_nav_tool.py`
  - `process_one_fund(...)` 新增参数 `allow_missing_event_until`
  - 新增 `_extract_dates_from_missing_error(...)` 用于解析缺失事件日期
  - 在计算时捕获缺失事件异常，按阈值决定“继续计算”或“失败”
  - `process_all_funds(...)` 新增透传参数 `allow_missing_event_until`
  - CLI 新增参数 `--allow-missing-event-until`

测试已补并通过：

- `myanalyser/test_adjusted_nav_tool.py`
  - 新增“阈值内允许继续产出”测试
  - 新增“晚于阈值仍失败”测试
- 执行结果：`Ran 7 tests ... OK`

你可以这样用：

```bash
source myanalyser/.venv312/bin/activate
python myanalyser/adjusted_nav_tool.py \
  --nav-dir myanalyser/myanalyser/data/test/fund_nav_by_code \
  --bonus-dir myanalyser/myanalyser/data/test/fund_bonus_by_code \
  --split-dir myanalyser/myanalyser/data/test/fund_split_by_code \
  --output-dir myanalyser/myanalyser/data/test/fund_adjusted_nav_by_code \
  --allow-missing-event-until 2010-12-31
```

---


# Q8

@fund_etl.py
增加一个 step7，通过下述接口爬取各基金成立以来的累计收益率走势，遍历方式和结果格式同step3
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="000006", indicator="累计收益率走势", period="成立来")
print(fund_open_fund_info_em_df)
#              日期   累计收益率
# 0    2019-03-19    0.00
# 1    2019-04-02    0.06
# 2    2019-04-15    0.23
# 3    2019-04-25    0.20
# 4    2019-05-10   -1.68
# ..          ...     ...
# 207  2026-01-09  213.27
# 208  2026-01-21  229.22
```

---

# A8
已完成，`step7` 已按 `step3` 同类模式接入，并支持 `period="成立来"`。

主要改动：
1. 新增累计收益率数据结构与接口校验
- 增加列定义 `CUM_RETURN_COLUMNS`：[fund_etl.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/fund_etl.py#L51)
- `verify_interfaces` 新增对 `indicator="累计收益率走势", period="成立来"` 的探测与必需列检查：[fund_etl.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/fund_etl.py#L116)

2. 新增 `step7` 核心逻辑（遍历方式/落盘格式同 step3）
- 通用串行抓取器支持可选 `period` 参数（step4/5 不受影响）：[fund_etl.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/fund_etl.py#L500)
- 新增标准化函数 `_normalize_cum_return`（输出 `基金代码, 日期, 累计收益率`，日期格式化，收益率数值化）：[fund_etl.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/fund_etl.py#L708)
- 新增运行入口 `run_step7_cum_return`，使用 `indicator="累计收益率走势"` + `period="成立来"`：[fund_etl.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/fund_etl.py#L721)

3. CLI 与默认路径接入
- 增加输出目录和失败日志路径：`fund_cum_return_by_code` / `failed_cum_return.jsonl`：[fund_etl.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/fund_etl.py#L763)
- `--mode` 增加 `step7` 和 `retry-cum-return`：[fund_etl.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/fund_etl.py#L786)
- `main` 增加 `step7` 执行分支与重试分支（`retry-all` 包含）：[fund_etl.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/fund_etl.py#L881)

4. 测试补齐
- 更新 `verify_interfaces` 的 mock 调用序列（新增累计收益率接口）：[test_fund_etl.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/test_fund_etl.py#L26)
- 新增 `test_step7_cum_return_write_rows`，校验调用参数、输出列、写入行数：[test_fund_etl.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/test_fund_etl.py#L376)
- 闭环测试 `test_closed_loop_all_steps` 增加 step7：[test_fund_etl.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/test_fund_etl.py#L414)

验证结果：
- 执行：`source .venv312/bin/activate && python -m unittest test_fund_etl.py`（工作目录 `myanalyser`）
- 结果：`Ran 12 tests ... OK`

---

# Q9

编写一个单独的比对脚本，功能为对比本地计算的复权收益率和远程查询得到的累计收益率，输入参数为基本目录base-dir，
对比方法为
1、选取 base-dir 目录下的 fund_adjusted_nav_by_code（本地计算的复权净值）和fund_cum_return_by_code（远程查询得到的累计收益率）目录。
2、对照检查这两个目录下，各个基金编码是否在两边都有。如果存在只有一边有，另一边没有的，在错误日志jsonl文件记录数据缺失。
3、对每一个两边都有的基金，遍历进行以下步骤：
3.1、选取两边文件中都存在的最后一个日期作为公共的结束日期（如果没有这样的日期也视为数据缺失）。
3.2、从前往后遍历两边的数据日期，如果某日期只有一边存在，则跳过并计数日期缺失。两边都存在则作为参与比对日期开始比对。
3.3、比对方法为，对于上述给定的期初日期和期末日期，分别计算本地复权净值和远程查询得到的累计收益率的（期末值-期初值）/期初值，得到同一时段的本地收益率结果和远程收益率结果。计算这两个结果值的偏差（本地收益率结果-远程收益率结果）/本地收益率结果（分母为0则为-）。记录偏差类型（<1%、1%～2%、2%～5%、5%～10%、10%以上）。
4、汇总结果并持久化到结果文件，最终将所有基金的统计结果以 csv 形式输出一个汇总文件，以及按基金编码分文件的明细文件。
汇总文件表头为：基金代码、数据是否缺失（两个目录只有一边有，另一边没有该基金，或无法找到公共日期）、参与比对收益率的天数、因日期数据缺失跳过的天数、（<1%、1%～2%、2%～5%、5%～10%、10%以上）各区段收益率偏差占比（分母为参与比对收益率的天数）。
明细文件表头为：期初日期、期末日期、本地期初值、本地期末值、远程期初值、远程期末值、该时段本地计算的收益率、该时段远程收益率、本地远程收益率偏差、偏差类型。

参考base-dir:/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/myanalyser/data/test

---

讨论一个情况。我在  fund_adjusted_nav_by_code 目录下保存了调整后的基金复权净值天级数据。
我希望将这些数据用于特定日期回测自选基金组合的收益。

---

# Q10

编写一个单独的交易日数据完整性检查脚本。接收参数为 base-dir、开始日期、结束日期，逻辑是选取base-dir 下的fund_adjusted_nav_by_code目录，检查其中每个基金的数据，是否对于开始日期到结束日期之间（包含这两个日期）的 所有交易日（见@trade_dates.csv），fund_adjusted_nav_by_code中该基金是否有多少比例的数据完整性。
输出一个汇总结果，以及每个基金一个的明细文件。都是csv形式。
汇总文件名包含开始和结束日期，内容字段：基金编码、数据完整比例
明细文件字段：交易日日期、该日期数据是否存在

+

check_trade_day_data_integrity.py 增加一个逻辑，如果某基金在base-dir下的 fund_overview.csv （例如/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/myanalyser/data/fund_etl/fund_overview.csv ）中，成立时间晚于参数的开始时间，则在汇总和明细中都忽略该基金

---

# A10

已新增独立脚本：[check_trade_day_data_integrity.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/check_trade_day_data_integrity.py)

用法：
```bash
source myanalyser/.venv312/bin/activate
python myanalyser/check_trade_day_data_integrity.py \
  --base-dir /Users/zhuaoyuan/cursor-workspace/finance/myanalyser/myanalyser/data/test \
  --start-date 2024-01-02 \
  --end-date 2024-01-10
```

脚本实现了你要的逻辑：
- 从 `base-dir/fund_adjusted_nav_by_code` 遍历每个基金 CSV。
- 按 `myanalyser/trade_dates.csv` 的 `trade_date`，筛选开始到结束日期（含边界）的交易日。
- 计算每只基金的数据完整比例（存在交易日条数 / 区间交易日总数）。
- 生成输出（默认在 `base-dir/trade_day_integrity_reports`）：
  - 汇总文件：`trade_day_integrity_summary_{start}_{end}.csv`
    - 字段：`基金编码`,`数据完整比例`
  - 明细目录：`details_{start}_{end}`
    - 每基金一个文件：`{基金编码}_{start}_{end}.csv`
    - 字段：`交易日日期`,`该日期数据是否存在`（是/否）

我已在你给的示例 `base-dir` 上跑通过一次，成功生成汇总和明细文件。

+

已完成修改：[check_trade_day_data_integrity.py](/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/check_trade_day_data_integrity.py)

新增逻辑如下：
- 脚本会读取 `base-dir/fund_overview.csv`。
- 解析基金成立日期（优先列 `成立日期/规模`，否则 `成立日期`）。
- 若某基金成立日期 `>` `--start-date`，则该基金会被**完全忽略**：
  - 不出现在汇总文件中
  - 不生成该基金的明细文件

同时补充了输出统计：
- `基金文件数量`
- `纳入检查基金数量`（过滤后实际参与检查）

我已验证过滤生效（示例）：
- `--start-date 2013-03-01 --end-date 2013-03-08`
- 总基金文件 `24224`，纳入检查 `1133`（其余因成立时间晚于开始日期被忽略）。

---

# Q11

我想探讨这样一个功能，请你先不进行开发，而是和我讨论。
希望编写一个单独的脚本，基于此前持久化到 mysql/clickhouse 的基金数据实现按规则选择若干个基金，形成一个配置组合，并对该组合进行回测，给出回测报告。

假设待验证的投资周期固定为30天。

回测过程是这样的：
在指定日期范围内，每间隔15天就选取一个日期，对于得到的每个日期d1，选取晚于或等于它的最近一个交易日d2作为假设的最后一个有数据的历史交易日。
按基金申购规则，对于每个d2，我以其后的下一个交易日d3的复权净值（adusted_nav，下同）作为价格买入待回测的基金组合（以基金编码+权重表示），d3为持仓的第一天，假设在持仓满30个自然日之后的第一个交易日d4以d4的复权净值价格卖出。

基金管理费率、托管费率、销售服务费率等成本已经在净值中被扣除，无需考虑。

+

1. 15天调仓、30天持有 会导致持仓重叠：每个窗口独立评估。
2. 交易日定义要统一：统一使用 trade_dates.csv 
3. 明白。先只考虑用复权净值数据，没有这个担心。
4. 价格与可交易性
d3 或 d4 无净值怎么办：预先剔除，我会预先选取回测时段数据完整的基金
封闭期、暂停申购/赎回是否剔除：剔除
最低持有期限制是否纳入：先固定按30天来
5. 申购费、赎回费、转换费通常不在净值里，要不要忽略需要先定：忽略。
6. 组合收益计算口径：只在买入时考虑按权重分配，后续不做再平衡

以上这些是否还有疑议？没有的话接着讨论
+
直接给一版“最小可用回测报告结构（字段级）

---

# A11

这个思路整体是可行的，逻辑也很清晰。  
我这边主要有几个需要先定清楚的点，避免回测偏差：

1. `15天调仓、30天持有` 会导致持仓重叠  
每15天开一笔、持有30天，意味着同一时点通常有两期组合同时在场。  
要明确是：
- 每个窗口独立评估（事件研究式），还是
- 合并成真实资金曲线（组合叠加）

2. 交易日定义要统一  
`d2/d3/d4` 都依赖交易日历。要固定使用哪张交易日表（A股交易日？基金申赎日？），避免货基/QDII等特殊基金错配。

3. 避免未来函数（Look-ahead bias）  
在 `d2` 选基时，只能使用 `<= d2` 且当时“已可见”的数据。  
比如基金经理变更、季报持仓、规模数据通常有披露滞后，不能直接用“记录日期”。

4. 价格与可交易性  
你定义用 `adjusted_nav` 买卖很合理，但要明确异常处理：
- `d3` 或 `d4` 无净值怎么办（停牌、清盘、缺失）  
- 封闭期、暂停申购/赎回是否剔除  
- 最低持有期限制是否纳入（很多基金有7天/30天规则）

5. 成本口径  
你已明确管理费/托管费/销售服务费不再重复扣，这没问题。  
但申购费、赎回费、转换费通常不在净值里，要不要忽略需要先定。

6. 组合收益计算口径  
买入权重后，是：
- 持有期内权重漂移（更贴近真实买入持有），还是
- 每日再平衡到目标权重（通常不建议，除非策略就是这样）

如果你同意，我下一步可以先和你把“回测口径规范”写成一页（数据口径、交易规则、异常处理、绩效指标），再开始开发，这样后续实现不会反复返工。
+
没有疑议，这个口径现在已经足够清晰，可以继续往下细化。

建议下一步只再定3块，就能进入可实施方案讨论：

1. 选基规则输入  
- 你希望“按规则选基金”怎么表达：SQL 条件、Python 函数、还是配置文件（如 YAML）？  
- 输出是否固定为 `[(fund_code, weight), ...]`，并要求权重和=1。

2. 回测输出指标  
- 单窗口：组合区间收益、年化（可选）、最大回撤（窗口内）、波动率（可选）  
- 全部窗口汇总：窗口数、胜率、平均/中位数收益、分位数（P10/P50/P90）  
- 是否加基准对比（如沪深300/中证偏股基金指数）？

3. 回测报告形式  
- 先做表格型报告（CSV + Markdown）还是直接 HTML 图文报告？  
- 你更关心“每个窗口明细”还是“汇总结论优先”？

你如果同意，我下一条可以直接给你一版“最小可用回测报告结构（字段级）”，我们对着字段逐项确认。
+
**最小可用回测报告结构（字段级）**

**1. 运行参数快照（run_summary，1行）**
- `run_id`: 本次回测唯一ID
- `run_time`: 回测执行时间
- `start_date`: 回测起始日期（用户输入）
- `end_date`: 回测结束日期（用户输入）
- `rebalance_interval_days`: 调仓间隔（固定15）
- `holding_period_days`: 持有自然日（固定30）
- `trade_calendar`: 交易日历来源（固定 `myanalyser/trade_dates.csv`）
- `fee_mode`: 费用口径说明（忽略申购/赎回/转换费）
- `overlap_mode`: 窗口关系（固定“独立评估”）
- `selection_rule_id`: 选基规则标识（版本号或名称）

**2. 每窗口明细（window_detail，多行，核心表）**
- `window_id`: 窗口ID（递增）
- `d1_anchor_date`: 锚点日（每15天一个）
- `d2_last_hist_trade_date`: `>=d1` 最近交易日（选基可见历史截止）
- `d3_buy_date`: 买入日（`d2`后第1个交易日）
- `d4_sell_date`: 卖出日（持仓满30自然日后第1个交易日）
- `calendar_holding_days`: 自然日持有天数（应为>=30）
- `trading_holding_days`: 实际交易日持有天数
- `selected_fund_count`: 入选基金数
- `weight_sum`: 权重和（应为1）
- `portfolio_return`: 组合区间收益率（核心）
- `portfolio_nav_start`: 组合初始净值（通常1.0）
- `portfolio_nav_end`: 组合期末净值
- `max_drawdown_in_window`: 窗口内最大回撤（可选但建议）
- `volatility_in_window`: 窗口内波动率（可选）
- `status`: `ok` / `skipped`
- `skip_reason`: 跳过原因（如“无可交易基金”）

**3. 每窗口持仓快照（window_positions，多行）**
- `window_id`
- `fund_code`
- `weight`
- `buy_nav_at_d3`
- `sell_nav_at_d4`
- `fund_return`: 单基金区间收益率
- `contribution`: 对窗口组合收益贡献（`weight * fund_return`）

**4. 汇总统计（aggregate_summary，1行）**
- `total_windows`: 总窗口数
- `valid_windows`: 有效窗口数
- `skipped_windows`: 跳过窗口数
- `win_rate`: 胜率（`portfolio_return>0` 占比）
- `mean_return`: 平均窗口收益
- `median_return`: 中位数窗口收益
- `std_return`: 窗口收益标准差
- `p10_return`: 10分位收益
- `p50_return`: 50分位收益
- `p90_return`: 90分位收益
- `best_window_return`: 最佳窗口收益
- `worst_window_return`: 最差窗口收益

**5. 导出文件（最小集合）**
- `backtest_run_summary.csv`
- `backtest_window_detail.csv`
- `backtest_window_positions.csv`
- `backtest_aggregate_summary.csv`
- `backtest_report.md`（文字版结论，引用以上表）

如果你愿意，下一步我可以继续给你这4张CSV的“字段类型定义 + 示例行”。

---
TODO 

* 低优
fund_etl.py 失败日志改为csv格式
补全货币基金的净值数据

* 高优
讨论上层统计值的分析需求、持久化方案设计
剔除没有净值数据的基金

3. 核心指标
3.1 年化收益率
3.2 上涨日/月/季数比例
3.3 日/月涨跌幅标准差
3.4 核心指标总结
4. 辅助指标
4.1 最大回撤率
4.2 第二大回撤率
4.3 月涨跌幅最大值比中值倍数
4.4 前1周/前2周/前3周/前2月/前3月/前3季/前4季涨跌幅
4.5 夏普率
4.6 卡玛比率

上层指标统计表
我要做一个产出上层指标统计表的脚本，结果文件为 csv 格式，其中每一个基金占一行，列包含：
```
基金代码
基金名称
期初日期
期末日期
规模-亿元
成立年数

年化收益率
上涨季度比例
上涨月份比例
上涨星期比例
季涨跌幅标准差
月涨跌幅标准差
周涨跌幅标准差
最大回撤率

近3年年化收益率
近3年上涨季度比例
近3年上涨月份比例
近3年上涨星期比例
近3年季涨跌幅标准差
近3年月涨跌幅标准差
近3年周涨跌幅标准差
近3年最大回撤率

近1年年化收益率
近1年上涨月份比例
近1年上涨星期比例
近1年月涨跌幅标准差
近1年周涨跌幅标准差
近1年最大回撤率
前1月涨跌幅
月涨跌幅

夏普比率
卡玛比率

该基金以上每项数值类指标在所有基金中的分别排名（一项指标对应一个排名，表现越好对应排名越靠前，例如年化收益率越高越好，上涨季度比例越高越好，涨跌幅标准差越小越好，回撤率越小越好）

基金类型
申购状态	
赎回状态	
下一开放日	
购买起点	
日累计限定金额
管理费率	
托管费率	
销售服务费率	
最高认购费率
最近更新日期
最近人事变动日期
```
其中用于计算的净值数据全部来自fund_adjusted_nav_by_code，买卖规则相关信息来自fund_purchase.csv，基本信息来自fund_overview.csv，人事信息来自fund_personnel_by_code。先不改代码，而是先设计一下，考虑当前数据是否足够完整实现该功能，是否需要添加一个用于辅助计算的中间层，以及其他可能存在的问题。



基金成立年数＞3年 （年份越长业绩数字越能反映基金真实特性）
近3年年化收益率＞4%（追求5-7%，但收益条件放宽到4%，不再是硬性条件）
近3年上涨季度比例＞80%（大时间尺度上的赚钱概率）
近3年上涨月份比例＞70%（每个月收益报表上飘红的概率最大）
月涨跌幅最大值比中值倍数＞0且＜20（排除掉净值突然异常暴涨的基金）
封闭类型<>封闭/锁定（封闭和锁定类型的基金流动性差，不能随时赎回）




年化收益率，百分比形式表示，保留两位小数
上涨季度比例，百分比形式表示，保留整数
上涨月份比例，百分比形式表示，保留整数
上涨星期比例，百分比形式表示，保留整数
季涨跌幅标准差，百分比形式表示，保留两位小数
月涨跌幅标准差，百分比形式表示，保留两位小数
周涨跌幅标准差，百分比形式表示，保留两位小数
最大回撤率，百分比形式表示，保留两位小数

近3年年化收益率，百分比形式表示，保留两位小数
近3年上涨季度比例，百分比形式表示，保留整数
近3年上涨月份比例，百分比形式表示，保留整数
近3年上涨星期比例，百分比形式表示，保留整数
近3年季涨跌幅标准差，百分比形式表示，保留两位小数
近3年月涨跌幅标准差，百分比形式表示，保留两位小数
近3年周涨跌幅标准差，百分比形式表示，保留两位小数
近3年最大回撤率，百分比形式表示，保留两位小数

近1年年化收益率，百分比形式表示，保留两位小数
近1年上涨月份比例，百分比形式表示，保留整数
近1年上涨星期比例，百分比形式表示，保留整数
近1年月涨跌幅标准差，百分比形式表示，保留两位小数
近1年周涨跌幅标准差，百分比形式表示，保留两位小数
近1年最大回撤率，百分比形式表示，保留两位小数
前1月涨跌幅，百分比形式表示，保留两位小数
月涨跌幅，百分比形式表示，保留两位小数

夏普比率，保留两位小数
卡玛比率，保留两位小数
