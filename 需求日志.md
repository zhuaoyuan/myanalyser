# Q1

使用 akshare 获取基金数据，并保存到本地。
步骤为；
1. 获取基金列表和申购信息，方法：
```
fund_purchase_em_df = ak.fund_purchase_em()
```
提取结果中的字段：基金代码、基金简称、申购状态、赎回状态、下一开放日、购买起点、日累计限定金额、手续费
将结果持久化到文件。

2. 根据1中得到的结果文件，依次根据基金代码使用下述方法获取基金详情：
```
fund_overview_em_df = ak.fund_overview_em(symbol="015641")
```
提取结果中的字段：基金代码、基金简称、基金全称、基金类型、发行日期、成立日期/规模、资产规模、份额规模、基金管理人、基金托管人、基金经理人、成立来分红、管理费率、托管费率、销售服务费率、最高认购费率、业绩比较基准、跟踪标的。将该结果持久化到文件。每次查询前预先检查，如果结果文件中存在该基金代码，则跳过。

3. 根据1中得到的结果文件，依次根据基金代码，获取基金历史累计净值，方法：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="166009", indicator="累计净值走势")
```
每行按基金代码、净值日期、累计净值的格式持久化到结果文件。


注意：
1. 对每个要使用的接口，都先测试调用一遍，确认结果的数据结构，以及在真实响应结果中，所有需求提及所需的字段是否都能找到对应的字段，如果有问题需确认和排查清楚。
2. 对于步骤2和3，接口是按基金代码单个获取的，且总基金数量很多。需要考虑如果失败如何重试，如果重试一直失败如何记录、是否支持后续手动重试，而不是从头开始。
3. 对于步骤3，数据量可能比较大。预计百万级别。需要考虑持久化结果的方式如何设计。
4. 需要设计测试用例，每一步任务可以自动化闭环验证。


---

# A1

已实现一套独立于现有本地逻辑的 AkShare 基金采集脚本与自动化测试，满足你列的 1/2/3 步和注意事项。

新增文件

fund_etl.py
test_fund_etl.py
实现内容

步骤1：调用 ak.fund_purchase_em()，提取并落盘
字段：基金代码, 基金简称, 申购状态, 赎回状态, 下一开放日, 购买起点, 日累计限定金额, 手续费
步骤2：基于步骤1结果按代码调用 ak.fund_overview_em(symbol=...)
结果中做字段映射：AkShare 的 净资产规模 -> 需求字段 资产规模
先检查已存在结果文件里的基金代码，存在则跳过
失败自动重试（可配置），最终失败写入 jsonl 失败日志
支持仅对失败代码重跑（无需从头开始）
步骤3：基于步骤1结果按代码调用 ak.fund_open_fund_info_em(symbol=..., indicator="累计净值走势")
按 基金代码, 净值日期, 累计净值 持久化
为百万级数据采用“按基金代码分文件”存储：{code}.csv，天然支持断点续跑与跳过已完成代码
失败同样记录并支持后续失败重跑
接口预检：verify_interfaces() 会真实调用三类接口并输出字段校验报告（含缺失项、列名映射结论）
CLI 用法

全流程：
fund_etl.py --mode all
仅预检：
fund_etl.py --mode verify
单步：step1 | step2 | step3
重跑失败：retry-overview | retry-nav | retry-all
可调重试：--max-retries、--retry-sleep
输出目录可配：--base-dir（默认 myanalyser/data/fund_etl）
自动化测试

测试文件：test_fund_etl.py
覆盖点：
接口字段预检与“资产规模映射”校验
步骤1字段提取与落盘
步骤2已完成跳过、失败重试/记录
步骤3按代码文件落盘与行数校验
已执行：
python -m unittest -v test_fund_etl.py
结果：4 个测试全部通过
当前环境说明

我在当前沙箱里尝试了真实 --mode verify，因 DNS/外网限制无法访问 fund.eastmoney.com（不是代码错误）。
你在本机可联网环境运行上述命令即可生成真实校验报告和正式数据。

---

# Q2

步骤2、步骤3执行过程中以合适的间隔打印进度。
步骤2、步骤3使用多线程的方式，且使用持续增量持久化的方式，不要全部跑完后才持久化。
需要设计测试用例，每一步任务可以自动化闭环验证。
@fund_etl.py

---

# A2

已按你的要求完成改造，核心点如下。

步骤2/步骤3改为多线程执行
fund_etl.py (line 229)、fund_etl.py (line 338)
使用 ThreadPoolExecutor + as_completed 并发按基金代码抓取。
新增 max_workers 参数（CLI: --max-workers）。
步骤2/步骤3增加“合适间隔”的进度打印
fund_etl.py (line 56)、fund_etl.py (line 215)、fund_etl.py (line 289)、fund_etl.py (line 393)
新增 ProgressConfig(print_interval_seconds)。
执行中按时间间隔打印进度，结束时强制打印一次总结。
CLI 新增 --progress-interval。
持续增量持久化（不是全部跑完再写）
fund_etl.py (line 276)、fund_etl.py (line 385)
步骤2：每个 future 完成后立即 append 到 overview_csv。
步骤3：每个 future 完成后立即写对应 {code}.csv。
自动化闭环测试用例补齐
test_fund_etl.py (line 141)、test_fund_etl.py (line 217)、test_fund_etl.py (line 250)
新增步骤2并发+增量持久化+进度打印测试。
新增步骤3并发+进度打印+部分失败测试。
新增 step1→step2→step3 全流程闭环测试。
验证结果（本地执行）

命令：activate && cd myanalyser && python -m unittest -v test_fund_etl.py
结果：Ran 7 tests ... OK（全部通过）

---

# Q3 

1. 将 step3改为获取单位净值而不是累计净值，代码和结果示例：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="163402", indicator="单位净值走势")
print(fund_open_fund_info_em_df)
#             净值日期    单位净值  日增长率
# 0     2005-11-03  1.0000  0.00
# 1     2005-11-11  0.9999 -0.01
# 2     2005-11-16  0.9999  0.00
# 3     2005-11-17  0.9999  0.00
# 4     2005-11-18  1.0007  0.08
# ...          ...     ...   ...
# 4932  2026-02-09  0.8015  2.35
# 4933  2026-02-10  0.8060  0.56
# 4934  2026-02-11  0.8029 -0.38
# 4935  2026-02-12  0.8105  0.95
# 4936  2026-02-13  0.8002 -1.27
```

2. 增加step4，获取分红送配详情，代码和结果示例（如果无任何结果则对应结果文件为空，便于断点重试）：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="163402", indicator="分红送配详情")
print(fund_open_fund_info_em_df)
#        年份       权益登记日         除息日          每份分红       分红发放日
# 0   2021年  2021-12-16  2021-12-16  每份派现金0.1584元  2021-12-20
# 1   2020年  2020-08-10  2020-08-10  每份派现金0.0820元  2020-08-12
# 2   2019年  2019-09-24  2019-09-24  每份派现金0.1000元  2019-09-26
# 3   2018年  2018-09-19  2018-09-19  每份派现金0.1821元  2018-09-21
# 4   2017年  2017-08-28  2017-08-28  每份派现金0.2647元  2017-08-30
# 5   2016年  2016-12-12  2016-12-12  每份派现金0.6108元  2016-12-14
# 6   2015年  2015-01-13  2015-01-13  每份派现金0.1030元  2015-01-15
# 7   2014年  2014-07-17  2014-07-17  每份派现金0.0300元  2014-07-21
# 8   2011年  2011-12-20  2011-12-20  每份派现金0.0580元  2011-12-22
# 9   2010年  2010-10-20  2010-10-20  每份派现金0.0800元  2010-10-22
# 10  2009年  2009-08-17  2009-08-17  每份派现金0.1000元  2009-08-19
# 11  2008年  2008-12-19  2008-12-19  每份派现金0.0420元  2008-12-23
# 12  2007年  2007-06-25  2007-06-25  每份派现金0.1300元  2007-06-27
# 13  2006年  2006-03-13  2006-03-13  每份派现金0.0760元  2006-03-15
# 14  2006年  2006-01-24  2006-01-24  每份派现金0.0240元  2006-02-06
```

3. 增加step5，获取拆分详情，代码和结果示例（如果无任何结果则对应结果文件为空，便于断点重试）：
```
fund_open_fund_info_em_df = ak.fund_open_fund_info_em(symbol="163402", indicator="拆分详情")
print(fund_open_fund_info_em_df)
#       年份       拆分折算日  拆分类型    拆分折算比例
# 0  2007年  2007-05-11  份额折算  1:3.9939
```

注意：
1. step3、step4和step5都无需多线程请求，都要按合理间隔打印进度，每查完一次就持久化一个文件。

---

# A3

已按你的要求完成改造并验证通过。

变更如下：

1. `step3` 改为抓取“单位净值走势”，并改为串行请求  
- 抓取指标：`indicator="单位净值走势"`  
- 输出列：`基金代码, 净值日期, 单位净值, 日增长率`  
- 不再多线程执行；如果传入 `max_workers>1` 会提示忽略  
- 每个基金代码查询成功后立即落盘一个文件（`{code}.csv`）  
- 代码位置：`myanalyser/fund_etl.py:327`

2. 新增 `step4`：分红送配详情  
- 抓取指标：`indicator="分红送配详情"`  
- 输出目录：`fund_bonus_by_code`  
- 输出列：`基金代码, 年份, 权益登记日, 除息日, 每份分红, 分红发放日`  
- 串行请求，按进度间隔打印，单代码单文件持久化  
- 无数据时也会写出空文件（仅表头），便于断点重试  
- 代码位置：`myanalyser/fund_etl.py:540`

3. 新增 `step5`：拆分详情  
- 抓取指标：`indicator="拆分详情"`  
- 输出目录：`fund_split_by_code`  
- 输出列：`基金代码, 年份, 拆分折算日, 拆分类型, 拆分折算比例`  
- 串行请求，按进度间隔打印，单代码单文件持久化  
- 无数据时也会写出空文件（仅表头），便于断点重试  
- 代码位置：`myanalyser/fund_etl.py:564`

4. CLI 与路径已扩展  
- 新增模式：`step4`, `step5`, `retry-bonus`, `retry-split`  
- `all` 会执行到 step5；`retry-all` 会包含 bonus/split 重试  
- 新增失败日志：`failed_bonus.jsonl`, `failed_split.jsonl`  
- 代码位置：`myanalyser/fund_etl.py:592`, `myanalyser/fund_etl.py:606`

5. 接口校验 `verify_interfaces` 已同步  
- `step3` 校验改为单位净值字段  
- 新增 bonus/split 字段校验  
- 代码位置：`myanalyser/fund_etl.py:95`

6. 测试已同步并通过  
- 更新并新增了 step3/step4/step5 的单测（含空结果落盘场景）  
- 文件：`myanalyser/test_fund_etl.py`  
- 执行：`source myanalyser/.venv312/bin/activate && cd myanalyser && python -m unittest -q test_fund_etl.py`  
- 结果：`Ran 9 tests ... OK`

---

# Q4
增加step6，获取基金人事公告，代码和结果示例（如果无任何结果则对应结果文件为空，便于断点重试）：
```
fund_announcement_personnel_em_df = ak.fund_announcement_personnel_em(symbol="000001")
print(fund_announcement_personnel_em_df)
#       基金代码                               公告标题    基金名称        公告日期                  报告ID
# 0   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2013-06-29  AN201306290003484248
# 1   000001    华夏基金管理有限公司关于增聘华夏成长证券投资基金基金经理的公告  华夏成长混合  2014-03-18  AN201403180005270024
# 2   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2014-06-21  AN201406210006119867
# 3   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2015-01-09  AN201501090008098479
# 4   000001  华夏基金管理有限公司关于调整华夏成长证券投资公告基金基金经理的公告  华夏成长混合  2015-11-21  AN201511210011484696
# 5   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2017-01-14  AN201701140268312342
# 6   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2017-02-25  AN201702250364410226
# 7   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2017-03-30  AN201703300451418174
# 8   000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2021-02-24  AN202102241464811736
# 9   000001    华夏基金管理有限公司关于增聘华夏成长证券投资基金基金经理的公告  华夏成长混合  2021-09-18  AN202109181516930266
# 10  000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2022-04-13  AN202204131558964253
# 11  000001    华夏基金管理有限公司关于调整华夏成长证券投资基金基金经理的公告  华夏成长混合  2022-10-29  AN202210291579611414
```

---

# A4

已在 `myanalyser/fund_etl.py` 完成 `step6`（基金人事公告）接入，并补齐测试。

主要改动：
- 新增字段常量与标准化：
  - `myanalyser/fund_etl.py:50` `PERSONNEL_COLUMNS`
  - `myanalyser/fund_etl.py:598` `_normalize_personnel(...)`
- 新增采集步骤：
  - `myanalyser/fund_etl.py:608` `run_step6_personnel(...)`
  - 使用 `ak.fund_announcement_personnel_em(symbol=code)`
  - 串行逐基金抓取、按间隔打印进度、每个基金即时写文件
  - 无结果也会写出空 CSV（仅表头），用于断点续跑
- 接入 `verify` 检查：
  - `myanalyser/fund_etl.py:111` 增加 `fund_announcement_personnel_em` 调用
  - `myanalyser/fund_etl.py:172` 增加所需字段校验结果
- 接入 CLI 与重试：
  - `myanalyser/fund_etl.py:731` 新增 `step6`
  - `myanalyser/fund_etl.py:737` 新增 `retry-personnel`
  - `myanalyser/fund_etl.py:709` 新增输出目录 `fund_personnel_by_code`
  - `myanalyser/fund_etl.py:715` 新增失败日志 `failed_personnel.jsonl`
  - `myanalyser/fund_etl.py:806` `all` 流程执行 `step6`
  - `myanalyser/fund_etl.py:866` `retry-all` 包含 `retry-personnel`

测试已补齐并通过：
- `myanalyser/test_fund_etl.py:317` 新增 `test_step6_personnel_write_empty_file_when_no_data`
- `myanalyser/test_fund_etl.py:432` 闭环测试扩展到 step6
- 执行命令：
  - `source myanalyser/.venv312/bin/activate && cd myanalyser && python -m unittest -q test_fund_etl.py`
- 结果：
  - `Ran 10 tests ... OK`

---

# Q5
针对failed_nav.jsonl编写一个单独的工具脚本，支持将指定失败日志文件转成 csv 格式。

---

# A5

已完成，新增了一个独立工具脚本：

- `myanalyser/failed_log_to_csv.py`
- `myanalyser/test_failed_log_to_csv.py`

功能：
- 支持 `--input/-i` 指定失败日志 `jsonl` 文件
- 支持 `--output/-o` 指定输出 `csv` 文件（不传则默认同名 `.csv`）
- 自动按 `ts, stage, code, error` 优先输出列，其余字段自动追加
- 兼容多行错误文本（CSV 会自动正确转义）

你可以这样用：

```bash
python3 myanalyser/failed_log_to_csv.py \
  -i myanalyser/myanalyser/data/fund_etl/failed_nav.jsonl \
  -o myanalyser/myanalyser/data/fund_etl/failed_nav.csv
```

我已实跑成功，生成：
- `myanalyser/myanalyser/data/fund_etl/failed_nav.csv`（1191 行）

并且测试通过：
- 在 `myanalyser` 目录执行 `python3 -m unittest test_failed_log_to_csv.py` 通过。

---

# Q6

编写一个单独的工具脚本
基于单位净值、分红数据、拆分数据，计算各个基金的历史复权净值数据，以基金163402（/Users/zhuaoyuan/cursor-workspace/finance/myanalyser/myanalyser/data/samples, 既有分红又有拆分）为例试运行并验证。计算方法参考：

```
import pandas as pd
import re

def calculate_adjusted_nav(df_nav, df_dividend, df_split):
    """
    df_nav: 单位净值走势 (包含: 净值日期, 单位净值)
    df_dividend: 分红送配详情 (包含: 除息日, 每份分红)
    df_split: 拆分详情 (包含: 拆分折算日, 拆分折算比例)
    """
    
    # 1. 预处理数据格式
    df_nav['净值日期'] = pd.to_datetime(df_nav['净值日期'])
    df_nav = df_nav.sort_values('净值日期').reset_index(drop=True)
    
    # 2. 提取分红金额数字 (例如 "每份派现金0.1584元" -> 0.1584)
    df_dividend['除息日'] = pd.to_datetime(df_dividend['除息日'])
    df_dividend['分红金额'] = df_dividend['每份分红'].str.extract(r'(\d+\.\d+)').astype(float)
    
    # 3. 提取拆分比例 (例如 "1:3.9939" -> 3.9939)
    df_split['拆分折算日'] = pd.to_datetime(df_split['拆分折算日'])
    df_split['拆分比例'] = df_split['拆分折算比例'].str.split(':').str[-1].astype(float)

    # 4. 初始化复权因子列
    # adj_factor 代表：如果你在这一天之前持有，为了保持逻辑连续，历史价格需要缩放的比例
    df_nav['adj_factor'] = 1.0

    # 5. 处理分红（分红再投资逻辑）
    for _, row in df_dividend.iterrows():
        div_date = row['除息日']
        div_amt = row['分红金额']
        # 找到除息日当天的净值
        today_nav = df_nav.loc[df_nav['净值日期'] == div_date, '单位净值']
        if not today_nav.empty:
            nav_val = today_nav.values[0]
            # 复权因子 = (除息后净值 + 分红) / 除息后净值
            # 这意味着分红的钱按当天价格买回了基金，增加了份额
            factor = (nav_val + div_amt) / nav_val
            df_nav.loc[df_nav['净值日期'] == div_date, 'adj_factor'] = factor

    # 6. 处理拆分
    for _, row in df_split.iterrows():
        split_date = row['拆分折算日']
        split_ratio = row['拆分比例']
        # 拆分后净值变小，份额变多。复权因子即比例本身
        df_nav.loc[df_nav['净值日期'] == split_date, 'adj_factor'] = split_ratio

    # 7. 计算累计复权因子并求得复权净值
    # 使用 cumprod (累乘) 从前往后计算
    df_nav['cumulative_factor'] = df_nav['adj_factor'].cumprod()
    df_nav['复权净值'] = df_nav['单位净值'] * df_nav['cumulative_factor']

    return df_nav[['净值日期', '单位净值', '复权净值', 'cumulative_factor']]

# 使用示例 (假设你已经定义了那三个 df)
# res_df = calculate_adjusted_nav(df_nav, df_dividend, df_split)
# print(res_df.tail())
```

---

# A6

已完成，新增了一个独立工具脚本并用 `163402` 样例实跑验证。

**新增文件**
- `myanalyser/adjusted_nav_tool.py`
- `myanalyser/test_adjusted_nav_tool.py`

**实现内容**
- 读取三类输入：单位净值、分红、拆分（按基金代码对应 CSV）。
- 按你给的方法计算：
  - 分红因子：`(当日单位净值 + 分红金额) / 当日单位净值`
  - 拆分因子：拆分比例（如 `1:3.9939 -> 3.9939`）
  - 累乘得到 `cumulative_factor`
  - `复权净值 = 单位净值 * cumulative_factor`
- 支持批量和指定代码处理，CLI 参数：
  - `--nav-dir`
  - `--bonus-dir`
  - `--split-dir`
  - `--output-dir`
  - `--codes`（可选）

**测试与验证**
- 测试执行：`python -m unittest myanalyser/test_adjusted_nav_tool.py`
- 结果：2 个测试全部通过。
- 样例实跑命令已执行，输出：
  - `processed funds: 1`
  - `163402: rows=4937 range=2005-11-03~2026-02-13`
- 输出文件：
  - `myanalyser/myanalyser/data/samples/fund_adjusted_nav_by_code/163402.csv`
- 关键校验（163402）：
  - `2006-01-24 cumulative_factor = 1.022468`
  - `2006-03-13 cumulative_factor = 1.098786`
  - `2007-05-11 cumulative_factor = 4.3884424059`
  - 事件公式复算值与输出完全一致（差值 `0.0`）。

---

# Q7
再略微调整一下。当前缺失分红日、拆分日异常记录保持不变。但脚本额外支持一个参数，指定一个日期，如果发生缺失的分红日、拆分日异常的日期晚于该指定日期，则该基金整体认为是异常，不记录。除此之外还是记录复权计算结果。

---
# A7

已按你的新规则改完，行为如下：

- 默认行为不变：  
  - 缺失分红日/拆分日仍判异常，记录 `failed_adjusted_nav.jsonl`，不产出该基金结果。
- 新增参数：`--allow-missing-event-until YYYY-MM-DD`  
  - 若缺失事件日 `<=` 该日期：允许跳过这些缺失事件，继续计算并写出复权结果。  
  - 若缺失事件日 `>` 该日期：仍判异常，不记录该基金结果（并写失败日志）。

关键改动：

- `myanalyser/adjusted_nav_tool.py`
  - `process_one_fund(...)` 新增参数 `allow_missing_event_until`
  - 新增 `_extract_dates_from_missing_error(...)` 用于解析缺失事件日期
  - 在计算时捕获缺失事件异常，按阈值决定“继续计算”或“失败”
  - `process_all_funds(...)` 新增透传参数 `allow_missing_event_until`
  - CLI 新增参数 `--allow-missing-event-until`

测试已补并通过：

- `myanalyser/test_adjusted_nav_tool.py`
  - 新增“阈值内允许继续产出”测试
  - 新增“晚于阈值仍失败”测试
- 执行结果：`Ran 7 tests ... OK`

你可以这样用：

```bash
source myanalyser/.venv312/bin/activate
python myanalyser/adjusted_nav_tool.py \
  --nav-dir myanalyser/myanalyser/data/test/fund_nav_by_code \
  --bonus-dir myanalyser/myanalyser/data/test/fund_bonus_by_code \
  --split-dir myanalyser/myanalyser/data/test/fund_split_by_code \
  --output-dir myanalyser/myanalyser/data/test/fund_adjusted_nav_by_code \
  --allow-missing-event-until 2010-12-31
```

---
TODO 

* 低优
fund_etl.py 失败日志改为csv格式
补全货币基金的净值数据

* 高优
讨论上层统计值的分析需求、持久化方案设计
剔除没有净值数据的基金

3. 核心指标
3.1 年化收益率
3.2 上涨日/月/季数比例
3.3 日/月涨跌幅标准差
3.4 核心指标总结
4. 辅助指标
4.1 最大回撤率
4.2 第二大回撤率
4.3 月涨跌幅最大值比中值倍数
4.4 前1周/前2周/前3周/前2月/前3月/前3季/前4季涨跌幅
4.5 夏普率
4.6 卡玛比率

上层指标统计表
我要做一个产出上层指标统计表的脚本，结果文件为 csv 格式，其中每一个基金占一行，列包含：
```
基金代码
基金名称
期初日期
期末日期
规模-亿元
成立年数

年化收益率
上涨季度比例
上涨月份比例
上涨星期比例
季涨跌幅标准差
月涨跌幅标准差
周涨跌幅标准差
最大回撤率

近3年年化收益率
近3年上涨季度比例
近3年上涨月份比例
近3年上涨星期比例
近3年季涨跌幅标准差
近3年月涨跌幅标准差
近3年周涨跌幅标准差
近3年最大回撤率

近1年年化收益率
近1年上涨月份比例
近1年上涨星期比例
近1年月涨跌幅标准差
近1年周涨跌幅标准差
近1年最大回撤率
前1月涨跌幅
月涨跌幅

夏普比率
卡玛比率

该基金以上每项数值类指标在所有基金中的分别排名（一项指标对应一个排名，表现越好对应排名越靠前，例如年化收益率越高越好，上涨季度比例越高越好，涨跌幅标准差越小越好，回撤率越小越好）

基金类型
申购状态	
赎回状态	
下一开放日	
购买起点	
日累计限定金额
管理费率	
托管费率	
销售服务费率	
最高认购费率
最近更新日期
最近人事变动日期
```
其中用于计算的净值数据全部来自fund_adjusted_nav_by_code，买卖规则相关信息来自fund_purchase.csv，基本信息来自fund_overview.csv，人事信息来自fund_personnel_by_code。先不改代码，而是先设计一下，考虑是否需要添加一个用于辅助计算的中间层，以及可能存在的问题。



基金成立年数＞3年 （年份越长业绩数字越能反映基金真实特性）
近3年年化收益率＞4%（追求5-7%，但收益条件放宽到4%，不再是硬性条件）
近3年上涨季度比例＞80%（大时间尺度上的赚钱概率）
近3年上涨月份比例＞70%（每个月收益报表上飘红的概率最大）
月涨跌幅最大值比中值倍数＞0且＜20（排除掉净值突然异常暴涨的基金）
封闭类型<>封闭/锁定（封闭和锁定类型的基金流动性差，不能随时赎回）

